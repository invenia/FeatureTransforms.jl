var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = Transforms","category":"page"},{"location":"#Transforms","page":"Home","title":"Transforms","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [Transforms]","category":"page"},{"location":"#Transforms.AbstractScaling","page":"Home","title":"Transforms.AbstractScaling","text":"AbstractScaling <: Transform\n\nLinearly scale the data as ax + b, according to some statistics a and b.\n\n\n\n\n\n","category":"type"},{"location":"#Transforms.HoD","page":"Home","title":"Transforms.HoD","text":"HoD <: Transform\n\nGet the hour of day corresponding to the data.\n\n\n\n\n\n","category":"type"},{"location":"#Transforms.IdentityScaling","page":"Home","title":"Transforms.IdentityScaling","text":"IdentityScaling <: AbstractScaling\n\nRepresents the no-op scaling which simply returns the data it is applied on.\n\n\n\n\n\n","category":"type"},{"location":"#Transforms.LinearCombination","page":"Home","title":"Transforms.LinearCombination","text":"LinearCombination(coefficients) <: Transform\n\nCalculate the linear combination using the vector coefficients passed in.\n\n\n\n\n\n","category":"type"},{"location":"#Transforms.MeanStdScaling","page":"Home","title":"Transforms.MeanStdScaling","text":"MeanStdScaling(mean, std) <: AbstractScaling\n\nLinearly scale the data by a statistical mean and standard deviation std. This is also known as standardization, or the Z score transform. Once computed, the statistics of a MeanStdScaling are immutable.\n\nCan take a precomputed mean and std as arguments, or compute them from data.\n\nArguments\n\nmean::NamedTuple: tuple of mean values, named by the scope of values it applies to. (all=μ, ) will apply to all data; (1=μ1, 2=μ2) for AbstractArray data will apply μ1 to the first slice and μ2 to the second slice; (a=μ1, b=μ2) for Table data will apply μ1 to column a and μ2 to column b.\nstd::NamedTuple: similar to mean but for standard deviation values.\n\nKeyword arguments to apply\n\ninverse=true: inverts the scaling (e.g. to reconstruct the unscaled data)\neps=1e-3: replaces all 0 values in std before scaling (if inverse=false)\n\n\n\n\n\n","category":"type"},{"location":"#Transforms.MeanStdScaling-Tuple{Any}","page":"Home","title":"Transforms.MeanStdScaling","text":"MeanStdScaling(data; kwargs...) <: Scaling\n\nConstruct a MeanStdScaling using the mean and standard deviation of the data.\n\nnote: Note\ndims and cols keyword arguments must be specified the same way when constructing and applying the transform. Otherwise, the results will be inconsistent, or an error may occur.\n\nKeyword arguments\n\ndims=:: for AbstractArray data, the dimension(s) to compute statistics along.\ncols=nothing: for Table data, the column names to compute statistics for.\n\n\n\n\n\n","category":"method"},{"location":"#Transforms.OneHotEncoding","page":"Home","title":"Transforms.OneHotEncoding","text":"OneHotEncoding{R<:Real} <: Transform\n\nOne-hot encode the categorical value for each target element.\n\nConstruct a n-by-p binary matrix, given a Vector of target data x (of length n) and a Vector of all unique possible values in x (of length p).\n\nThe element [i, j] is true if the i^th target in x corresponds to the j^th possible value and false otherwise. Note that Rcan be specified to determine the return type of results. It defaults to a Matrix of Bools.\n\nNote that this Transform does not support specifying dims other than : (all dims) because it is a one-to-many transform (for example a Vector input produces a Matrix output).\n\n\n\n\n\n","category":"type"},{"location":"#Transforms.Periodic","page":"Home","title":"Transforms.Periodic","text":"Periodic{P, S}(f, period::P, [phase_shift::S]) <: Transform\n\nApplies a periodic function f with provided period and phase_shift to the data.\n\nThe period and phase_shift must have the same supertype of Real or Period, depending on whether the data is Real or TimeType respectively.\n\nnote: Note\nFor TimeType data, the result will change depending on the type of period given, even if the same amount of time is described. Example: Week(1) vs Second(Week(1)); the former starts the period on the most recent Monday, while the latter starts the period on the most recent multiple of 604800 seconds since time 0.\n\nFields\n\nf::Union{typeof(cos), typeof(sin)}: the periodic function\nperiod::Union{Real, Period}: the function period. Must be strictly positive.\nphase_shift::Union{Real, Period} (optional): adjusts the phase of the periodic function, measured in the same units as the input. Increasing the value translates the function to the right, toward higher/later input values.\n\n\n\n\n\n","category":"type"},{"location":"#Transforms.Periodic-Union{Tuple{P}, Tuple{Any,P}} where P","page":"Home","title":"Transforms.Periodic","text":"Periodic(f, period) -> Periodic\n\nA constructor for Periodic. Returns a Periodic transform with zero phase shift.\n\n\n\n\n\n","category":"method"},{"location":"#Transforms.Power","page":"Home","title":"Transforms.Power","text":"Power(exponent) <: Transform\n\nRaise the data by the given exponent.\n\n\n\n\n\n","category":"type"},{"location":"#Transforms.Transform","page":"Home","title":"Transforms.Transform","text":"Transform\n\nAbstract supertype for all Transforms.\n\n\n\n\n\n","category":"type"},{"location":"#Transforms._periodic","page":"Home","title":"Transforms._periodic","text":"_periodic(f, instant, period, phase_shift=Day(0))\n\nComputes the value of periodic function f at the given instant in time.\n\nArguments\n\nf: the periodic function\nperiod: the function period\nphase_shift: adjusts the phase of the periodic function. Increasing the value translates   the function to the right, toward higher/later input values.\n\n\n\n\n\n","category":"function"},{"location":"#Transforms._try_copy-Tuple{Any}","page":"Home","title":"Transforms._try_copy","text":"_try_copy(data)\n\nTry to copy the data, fallback to deepcopy if not supported. Not all objects support copy, but we should use it to improve performance if possible.\n\n\n\n\n\n","category":"method"},{"location":"#Transforms.apply","page":"Home","title":"Transforms.apply","text":"apply(data::T, ::Transform; kwargs...)\n\nApplies the Transform to the data. New transforms should usually only extend _apply which this method delegates to.\n\nWhere necessary, this should be extended for new data types T.\n\n\n\n\n\n","category":"function"},{"location":"#Transforms.apply!","page":"Home","title":"Transforms.apply!","text":"apply!(data::T, ::Transform; kwargs...) -> T\n\nApplies the Transform mutating the input data. This method delegates to apply under the hood so does not need to be defined separately.\n\nIf Transform does not support mutation, this method will error.\n\n\n\n\n\n","category":"function"},{"location":"#Transforms.apply!-Tuple{AbstractArray,Transform}","page":"Home","title":"Transforms.apply!","text":"apply!(A::AbstractArray, ::Transform; dims=:, kwargs...)\n\nApplies the Transform to each element of A, mutating the data.\n\n\n\n\n\n","category":"method"},{"location":"#Transforms.apply!-Union{Tuple{T}, Tuple{T,Transform}} where T","page":"Home","title":"Transforms.apply!","text":"apply!(table::T, ::Transform; cols=nothing)::T where T\n\nApplies the Transform to each of the specified columns in the table. If no cols are specified, then the Transform is applied to all columns.\n\n\n\n\n\n","category":"method"},{"location":"#Transforms.apply-Tuple{AbstractArray,Transform}","page":"Home","title":"Transforms.apply","text":"apply(A::AbstractArray, ::Transform; dims=:, inds=:, kwargs...)\n\nApplies the Transform to the elements of A.\n\nProvide the dims keyword to apply the Transform along a certain dimension. For example, given a Matrix, dims=1 applies to each column, while dims=2 applies to each row.\n\nProvide the inds keyword to apply the Transform to certain indices along the dims specified.\n\nNote: if dims === : (all dimensions), then inds will be the global indices of the array, instead of being relative to a certain dimension.\n\nThis method does not guarantee the data type of what is returned. It will try to conserve type but the returned type depends on what the original A was, and the dims and inds specified.\n\n\n\n\n\n","category":"method"},{"location":"#Transforms.apply-Tuple{AbstractArray{T,1} where T,LinearCombination}","page":"Home","title":"Transforms.apply","text":"apply(x::AbstractVector, LC::LinearCombination; inds=Colon())\n\nApplies the LinearCombination to each of the specified indices in x.\n\nIf no inds are specified, then the LinearCombination is applied to all elements.\n\n\n\n\n\n","category":"method"},{"location":"#Transforms.apply-Tuple{AbstractArray{T,2} where T,LinearCombination}","page":"Home","title":"Transforms.apply","text":"apply(x::AbstractMatrix, LC::LinearCombination; dims=1, inds=Colon())\n\nApplies the LinearCombination to each of the specified indices in x along the dimension specified, which defaults to applying it row-wise for each column of x.\n\nIf no inds are specified, then the LinearCombination is applied to all columns.\n\n\n\n\n\n","category":"method"},{"location":"#Transforms.apply-Tuple{Any,LinearCombination}","page":"Home","title":"Transforms.apply","text":"apply(x::Table, LC::LinearCombination; cols=nothing)\n\nApplies the LinearCombination to each of the specified cols in x.\n\nIf no cols are specified, then the LinearCombination is applied to all columns.\n\n\n\n\n\n","category":"method"},{"location":"#Transforms.apply-Tuple{Any,Transform}","page":"Home","title":"Transforms.apply","text":"apply(table, ::Transform; cols=nothing, kwargs...) -> Vector\n\nApplies the Transform to each of the specified columns in the table. If no cols are specified, then the Transform is applied to all columns.\n\nReturns an array containing each transformed column, in the same order as cols.\n\n\n\n\n\n","category":"method"},{"location":"#Transforms.transform","page":"Home","title":"Transforms.transform","text":"transform(::T, data)\n\nNon-mutating version of transform!.\n\n\n\n\n\n","category":"function"},{"location":"#Transforms.transform!","page":"Home","title":"Transforms.transform!","text":"transform!(::T, data)\n\nDefines the feature engineering pipeline for some type T, which comprises a collection of Transforms to be peformed on the data.\n\ntransform! should be overloaded for custom types T that require feature engineering.\n\n\n\n\n\n","category":"function"}]
}
